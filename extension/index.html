<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Juzu Extension Guide</title>
<link rel="stylesheet" href="./rocket-panda.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.1.0/css/font-awesome.min.css">
<style>
.CodeRay {
  background-color: hsl(0,0%,95%);
  border: 1px solid silver;
  color: black;
}
.CodeRay pre {
  margin: 0px;
}

span.CodeRay { white-space: pre; border: 0px; padding: 2px; }

table.CodeRay { border-collapse: collapse; width: 100%; padding: 2px; }
table.CodeRay td { padding: 2px 4px; vertical-align: top; }

.CodeRay .line-numbers {
  background-color: hsl(180,65%,90%);
  color: gray;
  text-align: right;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}
.CodeRay .line-numbers a {
  background-color: hsl(180,65%,90%) !important;
  color: gray !important;
  text-decoration: none !important;
}
.CodeRay .line-numbers a:target { color: blue !important; }
.CodeRay .line-numbers .highlighted { color: red !important; }
.CodeRay .line-numbers .highlighted a { color: red !important; }
.CodeRay span.line-numbers { padding: 0px 4px; }
.CodeRay .line { display: block; float: left; width: 100%; }
.CodeRay .code { width: 100%; }

.CodeRay .debug { color: white !important; background: blue !important; }

.CodeRay .annotation { color:#007 }
.CodeRay .attribute-name { color:#b48 }
.CodeRay .attribute-value { color:#700 }
.CodeRay .binary { color:#509 }
.CodeRay .char .content { color:#D20 }
.CodeRay .char .delimiter { color:#710 }
.CodeRay .char { color:#D20 }
.CodeRay .class { color:#B06; font-weight:bold }
.CodeRay .class-variable { color:#369 }
.CodeRay .color { color:#0A0 }
.CodeRay .comment { color:#777 }
.CodeRay .comment .char { color:#444 }
.CodeRay .comment .delimiter { color:#444 }
.CodeRay .complex { color:#A08 }
.CodeRay .constant { color:#036; font-weight:bold }
.CodeRay .decorator { color:#B0B }
.CodeRay .definition { color:#099; font-weight:bold }
.CodeRay .delimiter { color:black }
.CodeRay .directive { color:#088; font-weight:bold }
.CodeRay .doc { color:#970 }
.CodeRay .doc-string { color:#D42; font-weight:bold }
.CodeRay .doctype { color:#34b }
.CodeRay .entity { color:#800; font-weight:bold }
.CodeRay .error { color:#F00; background-color:#FAA }
.CodeRay .escape  { color:#666 }
.CodeRay .exception { color:#C00; font-weight:bold }
.CodeRay .float { color:#60E }
.CodeRay .function { color:#06B; font-weight:bold }
.CodeRay .global-variable { color:#d70 }
.CodeRay .hex { color:#02b }
.CodeRay .imaginary { color:#f00 }
.CodeRay .include { color:#B44; font-weight:bold }
.CodeRay .inline { background-color: hsla(0,0%,0%,0.07); color: black }
.CodeRay .inline-delimiter { font-weight: bold; color: #666 }
.CodeRay .instance-variable { color:#33B }
.CodeRay .integer  { color:#00D }
.CodeRay .key .char { color: #60f }
.CodeRay .key .delimiter { color: #404 }
.CodeRay .key { color: #606 }
.CodeRay .keyword { color:#080; font-weight:bold }
.CodeRay .label { color:#970; font-weight:bold }
.CodeRay .local-variable { color:#963 }
.CodeRay .namespace { color:#707; font-weight:bold }
.CodeRay .octal { color:#40E }
.CodeRay .operator { }
.CodeRay .predefined { color:#369; font-weight:bold }
.CodeRay .predefined-constant { color:#069 }
.CodeRay .predefined-type { color:#0a5; font-weight:bold }
.CodeRay .preprocessor { color:#579 }
.CodeRay .pseudo-class { color:#00C; font-weight:bold }
.CodeRay .regexp .content { color:#808 }
.CodeRay .regexp .delimiter { color:#404 }
.CodeRay .regexp .modifier { color:#C2C }
.CodeRay .regexp { background-color:hsla(300,100%,50%,0.06); }
.CodeRay .reserved { color:#080; font-weight:bold }
.CodeRay .shell .content { color:#2B2 }
.CodeRay .shell .delimiter { color:#161 }
.CodeRay .shell { background-color:hsla(120,100%,50%,0.06); }
.CodeRay .string .char { color: #b0b }
.CodeRay .string .content { color: #D20 }
.CodeRay .string .delimiter { color: #710 }
.CodeRay .string .modifier { color: #E40 }
.CodeRay .string { background-color:hsla(0,100%,50%,0.05); }
.CodeRay .symbol .content { color:#A60 }
.CodeRay .symbol .delimiter { color:#630 }
.CodeRay .symbol { color:#A60 }
.CodeRay .tag { color:#070 }
.CodeRay .type { color:#339; font-weight:bold }
.CodeRay .value { color: #088; }
.CodeRay .variable  { color:#037 }

.CodeRay .insert { background: hsla(120,100%,50%,0.12) }
.CodeRay .delete { background: hsla(0,100%,50%,0.12) }
.CodeRay .change { color: #bbf; background: #007; }
.CodeRay .head { color: #f8f; background: #505 }
.CodeRay .head .filename { color: white; }

.CodeRay .delete .eyecatcher { background-color: hsla(0,100%,50%,0.2); border: 1px solid hsla(0,100%,45%,0.5); margin: -1px; border-bottom: none; border-top-left-radius: 5px; border-top-right-radius: 5px; }
.CodeRay .insert .eyecatcher { background-color: hsla(120,100%,50%,0.2); border: 1px solid hsla(120,100%,25%,0.5); margin: -1px; border-top: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }

.CodeRay .insert .insert { color: #0c0; background:transparent; font-weight:bold }
.CodeRay .delete .delete { color: #c00; background:transparent; font-weight:bold }
.CodeRay .change .change { color: #88f }
.CodeRay .head .head { color: #f4f }

</style>
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-1292368-37', 'juzuweb.org');
    ga('send', 'pageview');

</script>
</head>
<body class="book toc2">
<div id="header">
<h1>Juzu Extension Guide</h1>
<span id="author">Julien Viet</span><br>
<span id="email"><a href="http://www.julienviet.com">http://www.julienviet.com</a></span><br>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ol type="none" class="sectlevel0">
<li><a href="#_plugins">Plugins</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_metamodel_plugins">Metamodel plugins</a></li>
<li><a href="#_runtime_plugins">Runtime plugins</a></li>
<li><a href="#_entity_processors">Entity processors</a></li>
<li><a href="#_value_types">Value types</a></li>
<li><a href="#_provider_factories">Provider factories</a></li>
<li><a href="#_templating_engine">Templating engine</a></li>
</ol>
</li>
<li><a href="#_value_types_2">Value types</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_implementing_the_code_valuetype_code">Implementing the <code>ValueType</code></a></li>
<li><a href="#_declaring_the_code_valuetype_code">Declaring the <code>ValueType</code></a></li>
</ol>
</li>
<li><a href="#_entity_processing">Entity processing</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_entity_unmarshallers">Entity unmarshallers</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_implementing_an_unmarshaller">Implementing an unmarshaller</a></li>
<li><a href="#_declaring_an_unmarshaller">Declaring an unmarshaller</a></li>
</ol>
</li>
<li><a href="#_entity_marshallers">Entity marshallers</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_implementing_a_marshaller">Implementing a marshaller</a></li>
<li><a href="#_declaring_a_marshaller">Declaring a marshaller</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#_asset_minifier">Asset minifier</a></li>
<li><a href="#_provider_factories_2">Provider factories</a></li>
<li><a href="#templatespi">Templating SPI</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_compiling_a_groovy_template">Compiling a Groovy template</a></li>
<li><a href="#_type_safe_url_resolution">Type safe URL resolution</a></li>
<li><a href="#_template_service_provider_interface">Template Service Provider Interface</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_template_providers">Template providers</a></li>
<li><a href="#_template_stub">Template stub</a></li>
</ol>
</li>
<li><a href="#_template_at_work">Template at work</a></li>
<li><a href="#_qualified_template_class">Qualified template class</a></li>
</ol>
</li>
<li><a href="#_bundlegen_plugin_tutorial">Bundlegen plugin tutorial</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_unbreakable_resource_bundles">Unbreakable resource bundles</a></li>
<li><a href="#_the_implementation">The implementation</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_the_metamodel_plugin_structure">The metamodel plugin structure</a></li>
<li><a href="#_processing_the_code_bundlegen_code_annotation">Processing the <code>@BundleGen</code> annotation</a></li>
<li><a href="#_generating_the_bundle_source">Generating the bundle source</a></li>
<li><a href="#_testing_the_plugin">Testing the plugin</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#_metrics_plugin_tutorial">Metrics plugin tutorial</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_creating_a_juzu_service">Creating a Juzu service</a></li>
<li><a href="#_service_initialization">Service initialization</a></li>
<li><a href="#_intercepting_the_request">Intercepting the request</a></li>
<li><a href="#_testing_the_plugin_2">Testing the plugin</a></li>
</ol>
</li>
</ol>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Juzu is a web framework based on MVC concepts for developing applications. Juzu is an
open source project developed on <a href="https://github.com/juzu/juzu">GitHub</a> licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2 License</a>.</p>
</div>
<div class="paragraph">
<p>This chapter continues the exploration of the architecture of Juzu, it is an essential read if you want to understand how Juzu
globally works and a recommanded read if you extend Juzu. Juzu philosophy is to provide a minimal core that
is extended with plugins: this design allows to extend Juzu with no need to touch its core.</p>
</div>

</div>
</div>
<h1 id="_plugins" class="sect0"><a class="anchor" href="#_plugins"></a>Plugins</h1>
<div class="paragraph">
<p>Juzu plugins can be classified according several criterions. Let&#8217;s study the different kind of plugins possible.</p>
</div>
<div class="sect1">
<h2 id="_metamodel_plugins"><a class="anchor" href="#_metamodel_plugins"></a>Metamodel plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A metamodel plugin is executed at compilation time when the application is compiled. Usually it reacts to Java
annotations in order to:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Validate the application : make checks depending on Java annotations</p>
</li>
<li>
<p>Read or write application resources : create new resources</p>
</li>
<li>
<p>Generate Java code : the generated code will be transparently compiled by the Java compiler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a metamodel plugin is not happy, it can fail the current by reporting an error to the Java compiler.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_runtime_plugins"><a class="anchor" href="#_runtime_plugins"></a>Runtime plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A runtime plugin is executed during the execution of the web application. A runtime plugin can create objects
that will be available for the application. Such objects are usually consumed by the application thanks to the
IOC container.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_entity_processors"><a class="anchor" href="#_entity_processors"></a>Entity processors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity processors map the request and response stream to Java objects.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_value_types"><a class="anchor" href="#_value_types"></a>Value types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value types map the controller request parameters to request parameters.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_provider_factories"><a class="anchor" href="#_provider_factories"></a>Provider factories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A provider factory provides plugability for integrating beans that are not managed natively by the IOC container
but needs to be integrated inside the container.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_templating_engine"><a class="anchor" href="#_templating_engine"></a>Templating engine</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Juzu can easily be extended with new templating engine. Templating engine integrates of course at runtime, however
they can optionally be part of the compilation phase of the application for validating templates or for creating
resources or classes to be used at runtime.</p>
</div>

</div>
</div>

<h1 id="_value_types_2" class="sect0"><a class="anchor" href="#_value_types_2"></a>Value types</h1>
<div class="paragraph">
<p>Value types is a Juzu plugin for dealing with controller parameters that can trivially be converted from and to strings.
In this section we will explain how the <code>juzu.impl.value.ValueType</code> interface works.</p>
</div>
<div class="sect1">
<h2 id="_implementing_the_code_valuetype_code"><a class="anchor" href="#_implementing_the_code_valuetype_code"></a>Implementing the <code>ValueType</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">The ValueType abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">ValueType</span>&lt;T&gt; {

  <span class="comment">/**
   * The list of java classes this implementation can handle.
   *
   * @return the list of types.
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getTypes();

  <span class="comment">/**
   * Parse a string and returns the corresponding value type.
   *
   * @param element the element annotations
   * @param s the string to parse
   * @return the corresponding value
   * @throws java.lang.Exception any exception preventing the parse to succeed
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> T parse(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">String</span> s) <span class="directive">throws</span> <span class="exception">Exception</span>;

  <span class="comment">/**
   * Format a value and returns the corresponding string.
   *
   * @param element the element annotations
   * @param value the value to format
   * @return the corresponding string
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> format(<span class="predefined-type">AnnotatedElement</span> element, T value);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The base implementation should extend the <code>ValueType</code> interface and provide a class type for the <code>&lt;T&gt;</code> generic parameter
of the class:</p>
</div>
<div class="listingblock">
<div class="title">The ValueType abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DateValueType</span> <span class="directive">extends</span> ValueType&lt;java.util.Date&gt; {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getTypes()</code> interface should return the class type the value type is converting:</p>
</div>
<div class="listingblock">
<div class="title">The getTypes implementation</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getTypes() {
  <span class="keyword">return</span> <span class="predefined-type">Collections</span>.singleton(java.util.Date.class);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">

several types can be returned by the method, this is used by the <code>ValueType</code> that handle primitive types such
as <code>int</code>, <code>boolean</code>, etc&#8230;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally the <code>parse</code> and <code>format</code> methods need to be implemented too:</p>
</div>
<div class="listingblock">
<div class="title">The parse and format implementations</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="predefined-type">Date</span> parse(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">String</span> s) <span class="directive">throws</span> <span class="exception">ParseException</span> {
  <span class="keyword">return</span> getSimpleDateFormat(element).parse(s);
}

<span class="directive">public</span> <span class="predefined-type">String</span> format(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">Date</span> value) {
  <span class="keyword">return</span> getSimpleDateFormat(element).format(value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>parse</code> and <code>format</code> methods provides access to the <code>element</code> that is converted, the purpose of those
objects is to provide access to optional annotation the element may have. Such annotations can be used by the
value type for doing the conversion:</p>
</div>
<div class="listingblock">
<div class="title">Using the annotated element for configuring the SimpleDateFormat object</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">private</span> <span class="predefined-type">SimpleDateFormat</span> getSimpleDateFormat(<span class="predefined-type">AnnotatedElement</span> element) {
  <span class="predefined-type">Format</span> format = element.getAnnotation(<span class="predefined-type">Format</span>.class);
  <span class="keyword">return</span> format != <span class="predefined-constant">null</span> ? <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>(format.value()) : <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>();
}</code></pre>
</div>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_declaring_the_code_valuetype_code"><a class="anchor" href="#_declaring_the_code_valuetype_code"></a>Declaring the <code>ValueType</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value types are declared in the <code>META-INF/services/juzu.impl.value.ValueType</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>
</div>

<h1 id="_entity_processing" class="sect0"><a class="anchor" href="#_entity_processing"></a>Entity processing</h1>
<div class="paragraph">
<p>Juzu allows the application to interact with request and response entities with the <code>juzu.request.ClientContext</code> and
the <code>juzu.Response.Body</code> objects. Those objects are binary data (or character data) oriented and provide a low
 level interface for reading or writing request entities.</p>
</div>
<div class="paragraph">
<p>Juzu provides also a plugable higher level API for dealing with request entities such as <em>File Upload</em> or <em>Json</em>. In this
section we will explain how to implement such plugins.</p>
</div>
<div class="sect1">
<h2 id="_entity_unmarshallers"><a class="anchor" href="#_entity_unmarshallers"></a>Entity unmarshallers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity unmarshallers are plugins that decodes a <code>juzu.request.ClientContext</code> into a set of arguments that will be
used by Juzu when invoking the controller. The unmarshaller can manipulate those arguments, usually reading the
request entity. The <code>juzu.impl.request.EntityUnmarshaller</code> abstract class has two methods to implement, let&#8217;s review
them.</p>
</div>
<div class="listingblock">
<div class="title">The EntityUnmarshaller abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">EntityUnmarshaller</span> {

  <span class="comment">/**
   * Decide wether or not this reader accept to read the specified &lt;code&gt;mediaType&lt;/code&gt; argument.
   *
   * @param mediaType the media type to test
   * @return true if the media type is accepted
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">boolean</span> accept(<span class="predefined-type">String</span> mediaType);

  <span class="comment">/**
   * Unmarshall the entity from the {@link juzu.request.ClientContext}. This unmarshaller can modify the
   * request control arguments:
   * &lt;ul&gt;
   *   &lt;li&gt;the contextual arguments can be iterated and the value updated&lt;/li&gt;
   *   &lt;li&gt;the parameter arguments map can be freely modified&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param mediaType the request media type
   * @param context the client context for reading the entity
   * @param contextualArguments the contextual arguments
   * @param parameterArguments the contextual parameters
   * @throws IOException anything preventing the read operation to succeed
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> unmarshall(
      <span class="predefined-type">String</span> mediaType,
      ClientContext context,
      <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;ContextualParameter, <span class="predefined-type">Object</span>&gt;&gt; contextualArguments,
      <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, RequestParameter&gt; parameterArguments) <span class="directive">throws</span> <span class="exception">IOException</span>;

}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_an_unmarshaller"><a class="anchor" href="#_implementing_an_unmarshaller"></a>Implementing an unmarshaller</h3>
<div class="paragraph">
<p>The <code>accept</code> method is quite simple to implement, it should return true when the unmarshaller wants to unmarshall
the incoming request, for instance:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> accept(<span class="predefined-type">String</span> mediaType) {
  <span class="keyword">return</span> mediaType.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>unmarshall</code> method will be invoked when the <code>accept</code> method returns true. At this moment, the unmarshaller should
read the entity data using the <code>ClientContext</code> interface and update the request arguments. There are two kinds of
request arguments that can be modified:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>parameter arguments using the <code>parameterArguments</code> method parameter</p>
</li>
<li>
<p>contextual arguments using the <code>contextualArguments</code> method parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Parameter arguments is a mutable map that provides string parameter values, those parameters are used by Juzu at
a later stage when invoking the controller handler. Those parameters can be used as is, or can be transformed into
other types via the <code>ValueType</code> extension or the <code>@Mapped</code> bean mapping. The <em>File Upload</em> unmarshaller
will create parameter arguments when reading the file upload form.</p>
</div>
<div class="paragraph">
<p>Contextual arguments are any controller argument that are not parameter arguments (i.e any type that is not a <code>ValueType</code>
or annotated with <code>@Mapped</code>). The unmarshall method can iterate over such arguments and modify them freely. The
<code>ContextualParameter</code> object provides the <em>name</em>, <em>class+ and _generic type+ of the argument. Those shall be used by
 the unmarshaller to properly modify the arguments. The _File Upload</em> unmarshaller will look at the contextual
 arguments having the type <code>org.apache.commons.fileupload.FileItem</code> and the right argument name to do the match.</p>
</div>

</div>
<div class="sect2">
<h3 id="_declaring_an_unmarshaller"><a class="anchor" href="#_declaring_an_unmarshaller"></a>Declaring an unmarshaller</h3>
<div class="paragraph">
<p>Unmarshallers are declared in the <code>META-INF/services/juzu.impl.request.EntityUnmarshaller</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_entity_marshallers"><a class="anchor" href="#_entity_marshallers"></a>Entity marshallers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity marshallers are plugins that encodes an object, usually returned by a controller handler into binary data
sent with the response. The <code>juzu.impl.request.EntityMarshaller</code> abstract class has a single method <em>marshall</em>
to implement, let&#8217;s review it.</p>
</div>
<div class="sect2">
<h3 id="_implementing_a_marshaller"><a class="anchor" href="#_implementing_a_marshaller"></a>Implementing a marshaller</h3>
<div class="listingblock">
<div class="title">The EntityMarshaller abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">EntityMarshaller</span> {

  <span class="comment">/**
   * Marshall the object for the specified &lt;code&gt;mimeType&lt;/code&gt; or return null.
   *
   * @param mimeType the mime type to test
   * @param annotations the contextual annotations
   * @param object the object to marshall  @return the corresponding streamable
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> Streamable marshall(<span class="predefined-type">String</span> mimeType, <span class="predefined-type">AnnotatedElement</span> annotations, <span class="predefined-type">Object</span> object);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The marshall method will be invoked by Juzu, when a controller returns an unknown object response (i.e an object
that does not inherit from the <code>juzu.Response</code> class). The marshall method can either return a null response to
signal that it cannot handle it or a <code>Streamable</code> implementation that will be used to create a <code>juzu.Response</code>.</p>
</div>

</div>
<div class="sect2">
<h3 id="_declaring_a_marshaller"><a class="anchor" href="#_declaring_a_marshaller"></a>Declaring a marshaller</h3>
<div class="paragraph">
<p>Unmarshallers are declared in the <code>META-INF/services/juzu.impl.request.EntityMarshaller</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>

</div>
</div>

<h1 id="_asset_minifier" class="sect0"><a class="anchor" href="#_asset_minifier"></a>Asset minifier</h1>
<div class="paragraph">
<p>An asset minifier is simple interface providing the opportunity to transform the original source files into
a new version that is a minified version of this source.</p>
</div>
<div class="paragraph">
<p>A minifier should implement the <code>juzu.plugin.assetMinifier</code> interface and provide a no argument constructor.
Minification occurs at compilation time when the annotations are processed: Juzu instantiates a minifier to
transform the physical asset and write the minified version on the disk. The minified asset name uses the original
asset name with the <em>-min</em> suffix placed before the asset name extension, for instance <em>jquery.js</em> will be
named as <em>jquery-min.js</em>, this is totally transparent for the user.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the implementation of the  minifier:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">NormalizeJSMinifier</span> <span class="directive">implements</span> Minifier {

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">InputStream</span> minify(<span class="predefined-type">String</span> name, <span class="predefined-type">String</span> type, <span class="predefined-type">InputStream</span> stream) <span class="directive">throws</span> <span class="exception">IOException</span> {
    <span class="keyword">if</span> (type.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span>)) {
      NormalizeJSReader reader = <span class="keyword">new</span> NormalizeJSReader(<span class="keyword">new</span> <span class="predefined-type">InputStreamReader</span>(stream));
      <span class="predefined-type">String</span> s = Tools.read(reader);
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">ByteArrayInputStream</span>(s.getBytes());
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IOException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Can only process scripts and not </span><span class="delimiter">&quot;</span></span> + type + <span class="string"><span class="delimiter">&quot;</span><span class="content"> asset</span><span class="delimiter">&quot;</span></span>);
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>minify</code> method provides three arguments:
. the asset value, for instance <em>jquery.js</em>
. the asset type with possible values of <em>script</em> and <em>stylesheet</em>
. the asset stream</p>
</div>
<div class="paragraph">
<p>The implementation is quite simple it wraps, the <code>InputStream</code> argument and returns the minifying stream.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">

in this implementation the stream is buffered before returning the stream because Java does not provide an
out of the box <code>ReaderInputStream</code> but if it would be the case, that could be done on the fly instead of buffering. In
all case the implementation can chose between buffering the stream or transforming on the fly.
</td>
</tr>
</table>
</div>

<h1 id="_provider_factories_2" class="sect0"><a class="anchor" href="#_provider_factories_2"></a>Provider factories</h1>
<div class="paragraph">
<p>Provider factories provide plugability for integrating beans that are not managed by the IOC container. A provider
factory is dynamic: it is a factory for <code>javax.inject.Provider</code> that returns a provider for a specificied class. Usually
provider factories will lookup the service in a registry (like another IOC container) and returns a provider that
return them lazily or not.</p>
</div>
<div class="paragraph">
<p>The provider factory defines the <code>getProvider</code> method:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Returns a provider for a specific type or null if it cannot be produced.
   *
   * @param implementationType the implementation class object
   * @param &lt;T&gt;                the implementation generic type
   * @return a provider for this class or null
   * @throws Exception any exception that would prevent to obtain the provider
   */</span>
  &lt;T&gt; <span class="predefined-type">Provider</span>&lt;? <span class="directive">extends</span> T&gt; getProvider(<span class="predefined-type">Class</span>&lt;T&gt; implementationType)
    <span class="directive">throws</span> <span class="exception">Exception</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The factory implementation must provide a public zero argument constructor and it will be instantiated
during the application boostrap by Juzu to obtain the provider. The returned providers will then be bound into
the IOC container.</p>
</div>
<div class="paragraph">
<p>The IOC container uses the <code>java.util.ServiceLoader</code> discovery mechanism for finding provider factories when
 injection occurs.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s study a simple example with a provider for the current time:</p>
</div>
<div class="listingblock">
<div class="title">Time provider factory</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="keyword">package</span> <span class="namespace">my</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">TimeProviderFactory</span> <span class="directive">implements</span> java.inject.ProviderFactory {
  <span class="directive">public</span> &lt;T&gt; <span class="predefined-type">Provider</span>&lt;? <span class="directive">extends</span> T&gt; getProvider(<span class="directive">final</span> <span class="predefined-type">Class</span>&lt;T&gt; implementationType) <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="keyword">if</span> (implementationType == java.util.Date.class) {
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Provider</span>&lt;T&gt;() {
        <span class="directive">public</span> T get() {
          <span class="keyword">return</span> implementationType.cast(<span class="keyword">new</span> java.util.Date());
        }
      };
    }
    <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This provider should be declared in the <em>META-INF/services/juzu.inject.ProviderFactory</em> file:</p>
</div>
<div class="listingblock">
<div class="title">Time provider configuration</div>
<div class="content monospaced">
<pre>my.TimeProvider</pre>
</div>
</div>

<h1 id="templatespi" class="sect0"><a class="anchor" href="#templatespi"></a>Templating SPI</h1>
<div class="paragraph">
<p>This chapter dives into the template life cycle from the compilation time to the run time. We will describe the
template Service Provider Interface (SPI), the SPI is designed to make Juzu templating extensible and integrating
template engines in Juzu. This chapter is optional is you are only writing ab application with Juzu, however it is
a must read if you want to know more Juzu internals or if you want to understand how to integrate a
template engine in Juzu.</p>
</div>
<div class="paragraph">
<p>When a Juzu application is compiled, the Juzu annotation processor detects the <code>@Path</code> annotations and triggers
the compilation of the related templates. The template compilation can be split in two parts:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Generating the template companion class that inherits the <code>juzu.template.Template</code> class. This part is generic
and works with any templating system, it is entirely managed by Juzu.</p>
</li>
<li>
<p>Processing the template file, this task is delegated to the <code>TemplateProvider</code> interface and is extensible.
The provider allows to have several templating system in Juzu and decouples the template compilation process
from the details of the templating engine.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_compiling_a_groovy_template"><a class="anchor" href="#_compiling_a_groovy_template"></a>Compiling a Groovy template</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s study an example with the Groovy template at compilation time.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/templatespi/lifecycle1.png" alt="Life cycle" width="700">
</div>
<div class="title">Figure 1. Compiling a Groovy template</div>
</div>
<div class="paragraph">
<p>When the Java compiler is invoked, the following steps are executed</p>
</div>
<div class="olist arabic">

<ol class="arabic">
<li>
<p>The Java compiler triggers the Juzu annotation processor when it finds the <code>@Path</code> annotation</p>
</li>
<li>
<p>Juzu resolves the relative path to the <code>templates</code> package of the application</p>
<div class="olist loweralpha">

<ol class="loweralpha" type="a">
<li>
<p>When the template cannot be resolved a compilation error is triggered</p>
</li>
<li>
<p>Otherwise the template is loaded</p>
</li>
</ol>
</div>

</li>
<li>
<p>The template provider is looked up according to the file name extension, it generates the <em>index</em>.groovy_ source file</p>
</li>
<li>
<p>Juzu creates the <code>index</code> class that extends the <code>juzu.template.Template</code> class annotated by the <code>@Path("index.gtmpl")</code> annotation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After that the only remaining part is to compile the <em>index</em>.groovy_ source to a class. It can be achieved either at build time
using the <em>groovyc</em> compiler or at load time when the <code>index</code> template is loaded using a <code>GroovyClassLoader</code>. The former
approach makes the build a bit more complex (but not much as Groovy compilation is fairly well supported in build systems or IDEs)
as it requires to run a Groovy compilation but it will perform additional validation of the template as well as reduce the load
time of the template. The later approach will detect any compilation error (such as Groovy syntax error) at runtime
and the <em>index</em>.groovy_ compilation will take a few milliseconds.</p>
</div>
<div class="paragraph">
<p>This flexibility allows to use the lazy approach during development and when the application is released then the Groovy compiler
can be used to compile the <em>index</em>.groovy_.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_type_safe_url_resolution"><a class="anchor" href="#_type_safe_url_resolution"></a>Type safe URL resolution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy templates provides the <code>@{&#8230;}</code> syntax for generating URL from the application controllers. This section gives
an overview of the underlying resolution mechanism.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/templatespi/lifecycle2.png" alt="URL resolution" width="750">
</div>
<div class="title">Figure 2. Template URL resolution during compilation</div>
</div>
<div class="ulist">

<ul>
<li>
<p>Parse: the template is parsed into its model representation</p>
</li>
<li>
<p>Resolve: the <code>index</code> link is resolved againt the controller meta model</p>
</li>
<li>
<p>Validate: the <code>index</code> link is validated</p>
</li>
<li>
<p>Emit: the corresponding <em>index</em>.groovy_ file is emitted and save on the class output</p>
</li>
<li>
<p>Compile: the Groovy source is compiled into a class by the <em>groovyc</em> compiler (this part is done after <em>javac</em>)</p>
</li>
</ul>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_template_service_provider_interface"><a class="anchor" href="#_template_service_provider_interface"></a>Template Service Provider Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Juzu provides a Service Provider Interface (SPI) for integrating thirdparty template engine. Actually all template
system are integrated with the SPI. We will study briefly the integration points so you can integrate a template engine
of your choice in Juzu.</p>
</div>
<div class="sect2">
<h3 id="_template_providers"><a class="anchor" href="#_template_providers"></a>Template providers</h3>
<div class="paragraph">
<p>The <code>juzu.impl.template.spi.TemplateProvider</code> is the main entry point when a templating system is integrated. The
provider is triggered during the compilation phase by the APT system built into the Java compiler.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">TemplateProvider</span>&lt;M <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt; {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The provider must declare the template model <code>&lt;M&gt;</code> generic type, this type must be a serializable as Juzu will sometimes
write template models on the disk during the compilation. This usually happens only in Eclipse due its incremental
compiler architecture. The type specified by the provider is privately managed (i.e it is opaque for Juzu) and it
symbolizes an internal representation of the parsed source (usually an Abstract Syntax Tree), it will be used in
various methods of the provider.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a review of the methods of this class to have a better understanding.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Returns the template source extension without the dot recognised by
   * this provider. For instance it should return &lt;code&gt;gtmpl&lt;/code&gt;
   * for groovy templates.
   *
   * @return the source extension
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> getSourceExtension();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getSourceExtension()</code> method is used to determine what file extension the provider can compile. The implementation
 should return a constant value, for instance the Groovy provide simply returns the <code>gtmpl</code> value.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Parse the provided char sequence and return the corresponding template model.
   *
   * @param context the parse context
   * @param source the source to parse
   * @return the corresponding template model
   * @throws TemplateException any template related exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> M parse(
      ParseContext context,
      <span class="predefined-type">CharSequence</span> source) <span class="directive">throws</span> TemplateException;

  <span class="comment">/**
   * Process the template.
   *
   * @param context the process context
   * @param templateModel  the template to process
   * @throws TemplateException any template related exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> process(
      ProcessContext context,
      TemplateModel&lt;M&gt; templateModel) <span class="directive">throws</span> TemplateException;

  <span class="comment">/**
   * Provide an opportunity for emitting a file on the disk.
   *
   * @param context the emit context
   * @param templateModel the template
   * @throws TemplateException any template related exception
   * @throws IOException any io exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> emit(
      EmitContext context,
      TemplateModel&lt;M&gt; templateModel) <span class="directive">throws</span> TemplateException, <span class="exception">IOException</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>parse</code>, <code>process</code> and <code>emit</code> methods care about transforming the template source to its final representation:
the compiled template.</p>
</div>
<div class="ulist">

<ul>
<li>
<p>The <code>parse</code> method is invoked with the content of the template and returns a template model. The representation returned
by the parse method is a parsed representation of the template source. If a parsing error occurs the method can throw
a <code>TemplateException</code>.</p>
</li>
<li>
<p>The <code>process</code> method is invoked after the template is parsed with the necessary context for performing further
processing of the template, for instance the Groovy templating engine performs the resolution of type safe URLs or type
safe parameters declaration at this moment. During the process:</p>
<div class="ulist">

<ul>
<li>
<p>The provider can resolve other templates using the <code>ProcessContext</code>, if the template to resolve is not
yet loaded it will trigger the <code>parse</code>/<code>process</code>/<code>emit</code> lifecycle, it if was already processed the template
is simply returned</p>
</li>
<li>
<p>The implementation can resolve controller methods and translate them into method invocation, this is used for
checking type safe URL and translating them into controller companion invocation</p>
</li>
<li>
<p>The <code>juzu.impl.template.spi.TemplateModel</code> argument models the template, it has several fields such as the underlying
model or the template path</p>
</li>
<li>
<p>The implementation can declare type safe parameters using the <code>TemplateModel#addParameter(String)</code> method. The declared
parameters will be generated on the <code>juzu.template.Template</code> subclass</p>
</li>
</ul>
</div>

</li>
<li>
<p>The <code>emit</code> method is invoked when the template processing is over. The <code>EmitContext</code> interface can be used
to create resources during this round.</p>
</li>
</ul>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Return the template stub type.
   *
   * @return the template stub class
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> TemplateStub&gt; getTemplateStubType();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally the <code>getTemplateStubType()</code> returns the type of a java class that will be used for creating a template stub.
For each template, a stub is created, the stub is responsible for loading the template at runtime, i.e the original
template or the compiled template that may have been generated during compilation during the <code>emit</code> callback.</p>
</div>

</div>
<div class="sect2">
<h3 id="_template_stub"><a class="anchor" href="#_template_stub"></a>Template stub</h3>
<div class="paragraph">
<p>Template stubs are java classes created by Juzu for managing a template at runtime on behalf of the provider.
Each provider provides its own stub implementation as a <code>juzu.impl.template.spi.TemplateStub</code> subclass.</p>
</div>
<div class="paragraph">
<p>A stub must provide a public constructor accepting a <code>java.lang.String</code> argument: the template id. The template
 id if the class name of the generated template. In addition, a stub must implement two abstract methods:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Init the template with the associated resource.
   *
   * @param loader   the class loader
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> doInit(<span class="predefined-type">ClassLoader</span> loader);

  <span class="comment">/**
   * Performs template rendering.
   *
   * @param renderContext the render context
   * @throws TemplateExecutionException any execution exception
   * @throws IOException any io exception
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> doRender(TemplateRenderContext renderContext)
      <span class="directive">throws</span> TemplateExecutionException, <span class="exception">IOException</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doInit</code> method loads the template using the provided <code>ClassLoader</code>, it will be call only once before the
template is rendered. Usually it uses the template id provided during the construction of the template to
locate the template on the disk, in its original form or in its compiled form.</p>
</div>
<div class="paragraph">
<p>The <code>doRender</code> method renders the template using the provided <code>TemplateRenderContext</code>. The render context
provides the necessary hooks such as:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Producing markup</p>
</li>
<li>
<p>Setting the title</p>
</li>
<li>
<p>Obtaining the locale</p>
</li>
<li>
<p>Accessing parameters or application beans for resolving expressions</p>
</li>
</ul>
</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_template_at_work"><a class="anchor" href="#_template_at_work"></a>Template at work</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After having described the various pieces of the templating SPI, let&#8217;s look at how the template generated stubs
 are used by Juzu templating system at runtime.</p>
</div>
<div class="paragraph">
<p>When the controller declares the <em>index.gtmpl</em> template the compiler produces three artifacts
* the <code>index</code> class template inherits <code>juzu.template.Template</code>: it is the only class visible from the
controller and the whole application
* the <em>index</em>.groovy_ Groovy template is the effective template code: it produces the markup, resolve expressions, etc&#8230;</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/templatespi/lifecycle3.png" alt="At work" width="750">
</div>
<div class="title">Figure 3. index groovy at work</div>
</div>
<div class="paragraph">
<p>When a controller is instantiated, the <code>index</code> template instance is injected into the controller, the <code>@Path</code> annotation
plays an essential role because it&#8217;s a qualifier and that qualifier is used to distinguish the correct subclass to inject
in the controller.</p>
</div>
<div class="paragraph">
<p>When the template is created, the corresponding template stub is instantiated. When the template needs to be
rendered, the <code>doInit(ClassLoader)</code> method of the stub is invoked. At this moment the Groovy <code>index_</code> class is
loaded from the  class loader, when the class is not found, the <em>index</em>.groovy_ is loaded and it is compiled
on the fly.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_qualified_template_class"><a class="anchor" href="#_qualified_template_class"></a>Qualified template class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Controller can be injected with the <code>juzu.template.Template</code> class, however they can also be injected with
the template subclass that was genereted by Juzu: instead of using the qualified template injection,
the controller declares the template <em>index</em> subclass. This approach cab be used when type safe parameters
are used as only the <code>index</code> type declares the fluent API.</p>
</div>
<div class="paragraph">
<p>For instance if the <em>index.gtmpl</em> declares the <em>color</em> parameter the <code>index</code> class will look like:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@Path</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">index.gtmpl</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">index</span> <span class="directive">extends</span> Template {

  ...

  public index with() {
    <span class="keyword">return</span> <span class="keyword">new</span> index.Builder();
  }

  <span class="directive">public</span> <span class="type">class</span> <span class="class">Builder</span> <span class="directive">extends</span> Template.Builder {

    <span class="directive">public</span> Builder color(<span class="predefined-type">String</span> color) {
      <span class="comment">// Generated code</span>
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller can then use the fluent API:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Controller</span> {

  <span class="annotation">@Inject</span>
  <span class="annotation">@Path</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">index.gtmpl</span><span class="delimiter">&quot;</span></span>)
  Template index;

  <span class="annotation">@View</span>
  <span class="directive">public</span> Response.Content index() {
    <span class="keyword">return</span> index.with().color(<span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>).ok();
  }
}</code></pre>
</div>
</div>

</div>
</div>

<h1 id="_bundlegen_plugin_tutorial" class="sect0"><a class="anchor" href="#_bundlegen_plugin_tutorial"></a>Bundlegen plugin tutorial</h1>
<div class="paragraph">
<p>The bundlegen plugin tutorial provides guidance for the implementation of a Juzu metamodel plugin.</p>
</div>
<div class="sect1">
<h2 id="_unbreakable_resource_bundles"><a class="anchor" href="#_unbreakable_resource_bundles"></a>Unbreakable resource bundles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The bundlegen plugin generates a typed Java class for a resource bundle:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@BundleGen</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">mybundle</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Application</span>
<span class="keyword">package</span> <span class="namespace">my.app</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le&#8217;t suppose we have this <code>mybundle.properties</code> file:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre>hello_world=Hello World</pre>
</div>
</div>
<div class="paragraph">
<p>This will generate a <code>bundlegen</code> Java class, the application can then retrieve the entries via static methods:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="predefined-type">String</span> s = bundlegen.hello_world();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bundle will be loaded using the current user locale, providing unbreakable resource bundles!</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_the_implementation"><a class="anchor" href="#_the_implementation"></a>The implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will provide now a detailled analysis of the plugin structure and code. This plugin is a <em>metamodel plugin</em>,
it does all the work during the compilation: it processes <code>@BundleGen</code> annotations in order to generate
a Java class source for this bundle. The generated source will be transparently compiled by the Java compiler
 in the same compilation phase than the application.</p>
</div>
<div class="paragraph">
<p>The plugin will be packaged under the <code>examples.plugin.bundlegen</code>
package and provides three classes:</p>
</div>
<div class="ulist">

<ul>
<li>
<p><code>examples.plugin.bundlegen.BundleGen</code> annotation is the plugin <em>API</em> : the application will use this annotation for
describing its bundles</p>
</li>
<li>
<p><code>examples.plugin.bundlegen.impl.BundlResolver</code> is an utility class used by the generated code at <em>runtime</em> for
loading a bundle</p>
</li>
<li>
<p><code>examples.plugin.bundlegen.impl.BundleGenMetaModelPlugin</code> is the metamodel plugin triggered during by the
compilation phase by Juzu</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_the_metamodel_plugin_structure"><a class="anchor" href="#_the_metamodel_plugin_structure"></a>The metamodel plugin structure</h3>
<div class="paragraph">
<p>Let&#8217;s begin by describing the overral plugin structure.  The metamodel plugin <code>BundleGenMetaModelPlugin</code> extends
the <code>juzu.impl.plugin.application.metamodel.ApplicationMetaModelPlugin</code> base class. It must provide a no arguments public constructor</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">public</span> BundleGenMetaModelPlugin() {
    <span class="local-variable">super</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">bundlegen</span><span class="delimiter">&quot;</span></span>);
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This plugin must be declared in the <em>META-INF/services/juzu.impl.plugin.application.metamodel.ApplicationMetaModelPlugin</em>
file:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code>examples.plugin.bundlegen.impl.BundleGenMetaModelPlugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>To process the <code>@BundleGen</code> annotation the plugin needs to declare the annotations it has interest for, this
is done in the <code>init</code> method.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt;&gt; init(ProcessingContext env) {
    <span class="keyword">return</span> <span class="predefined-type">Collections</span>.&lt;<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">Annotation</span>&gt;&gt;singleton(BundleGen.class);
  }</code></pre>
</div>
</div>

</div>
<div class="sect2">
<h3 id="_processing_the_code_bundlegen_code_annotation"><a class="anchor" href="#_processing_the_code_bundlegen_code_annotation"></a>Processing the <code>@BundleGen</code> annotation</h3>
<div class="paragraph">
<p>During compilation our plugin will receive lifecycle callbacks for the <code>BundleGen</code> annotation:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> processAnnotationAdded(ApplicationMetaModel application, AnnotationKey key, AnnotationState added) {
    <span class="predefined-type">Name</span> type = key.getType();
    <span class="keyword">if</span> (type.toString().equals(BundleGen.class.getName())) {
      ElementHandle.Package pkg = (ElementHandle.Package)key.getElement();
      bundles.put(pkg, (<span class="predefined-type">String</span>)added.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>));
    }
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> processAnnotationRemoved(ApplicationMetaModel application, AnnotationKey key, AnnotationState removed) {
    <span class="predefined-type">Name</span> type = key.getType();
    <span class="keyword">if</span> (type.toString().equals(BundleGen.class.getName())) {
      ElementHandle.Package pkg = (ElementHandle.Package)key.getElement();
      bundles.remove(pkg);
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two callbacks are used to maintain a map with all the known annotations by the plugin. Indeed code generation
will not occur in those callbacks but in a later callback (<code>prePassivate</code>). The annotation key object provides
access to:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>the element declaring the annotation, in our case it is an <code>ElementHandle.Package</code> since our annotation
can only target Java packages</p>
</li>
<li>
<p>the annotation type, we use it to check this is our annotation: in our case the check is here for
educational purpose since we only register interest for the <code>@BundleGen</code> annotation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The annotation state is a map containing the various annotation members: we retrieve the <code>value</code> member that is
the name of the resource bundle we will use later.</p>
</div>

</div>
<div class="sect2">
<h3 id="_generating_the_bundle_source"><a class="anchor" href="#_generating_the_bundle_source"></a>Generating the bundle source</h3>
<div class="paragraph">
<p>Until now we focused on the plugin structure and the lifecycles of the framework. This part will show the implementation
 of the <code>prePassivate</code> callback we mentionned earlier:</p>
</div>
<div class="listingblock">
<div class="title">The <code>prePassivate</code> callback</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> prePassivate(ApplicationMetaModel application) {
    <span class="keyword">for</span> (<span class="predefined-type">Map</span>.Entry&lt;ElementHandle.Package, <span class="predefined-type">String</span>&gt; entry : bundles.entrySet()) {
      ElementHandle.Package pkg = entry.getKey();
      <span class="predefined-type">String</span> bundleName = entry.getValue();
      processBundle(application, pkg, bundleName);
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The
<code>prePassivate</code> method has the <code>application</code> argument which is the current application being processed it
can be used to access the overral application structure. The implementation simply iterates the
<code>bundles</code> map of the plugin calling the <code>processBundle</code> method:</p>
</div>
<div class="listingblock">
<div class="title">The <code>processBundle</code> method</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">private</span> <span class="type">void</span> processBundle(ApplicationMetaModel application, ElementHandle.Package pkg, <span class="predefined-type">String</span> bundleName) {
    ProcessingContext context = application.getProcessingContext();
    PackageElement pkgElt = context.get(pkg);
    <span class="predefined-type">Properties</span> properties = loadBundle(context, pkg, bundleName);
    <span class="keyword">if</span> (properties == <span class="predefined-constant">null</span>) {
      <span class="keyword">throw</span> BUNDLE_NOT_FOUND.failure(pkgElt, bundleName);
    } <span class="keyword">else</span> {
      <span class="keyword">try</span> {
        generateBundleClass(context, properties, pkgElt, bundleName);
      }
      <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {
        <span class="keyword">throw</span> CANNOT_CREATE_BUNDLE.failure(pkgElt, bundleName).initCause(e);
      }
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>processBundle</code> does three things:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>it uses processing context to load the resource bundle via the <code>loadBundle</code> method</p>
</li>
<li>
<p>when the bundle is found, the class generation is delegated to the <code>generateBundleClass</code> method</p>
</li>
<li>
<p>error handling</p>
<div class="ulist">

<ul>
<li>
<p>when the bundle is not found, the plugin raises a <code>BUNDLE_NOT_FOUND</code> exception</p>
</li>
<li>
<p>when the <code>generateBundleClass* method thows an +IOException</code> the <code>CANNOT_CREATE_BUNDLE</code> exception is raised</p>
</li>
</ul>
</div>

</li>
</ul>
</div>
<div class="paragraph">
<p>Raising an error is done via the <code>juzu.impl.compiler.ProcessingException</code>.  Providing the package
element is important as it allows the compiler to do a precise error reporting when showing the error.
Such exception can be created directly or via the <code>juzu.impl.compiler.MessageCode</code> class: it uses
the <code>ProcessingException</code> to create the notion of message code:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> MessageCode BUNDLE_NOT_FOUND = <span class="keyword">new</span> MessageCode(<span class="string"><span class="delimiter">&quot;</span><span class="content">BUNDLE_NOT_FOUND</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">The bundle %1$s cannot be resolved</span><span class="delimiter">&quot;</span></span>);
  <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> MessageCode CANNOT_CREATE_BUNDLE = <span class="keyword">new</span> MessageCode(<span class="string"><span class="delimiter">&quot;</span><span class="content">CANNOT_CREATE_BUNDLE</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">The bundle %1$s cannot be created</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>loadBundle</code> implementation uses the current <code>ProcessingContext</code> to load
the bundle property file the user will provide in the package containing the <code>@BundleGen</code> annotation:</p>
</div>
<div class="listingblock">
<div class="title">The <code>loadBundle</code> method</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">private</span> <span class="predefined-type">Properties</span> loadBundle(ProcessingContext context, ElementHandle.Package pkg, <span class="predefined-type">String</span> bundleName) {
    Path.Absolute absolute = pkg.getPackageName().resolve(bundleName + <span class="string"><span class="delimiter">&quot;</span><span class="content">.properties</span><span class="delimiter">&quot;</span></span>);
    FileObject bundle = context.resolveResourceFromSourcePath(pkg, absolute);
    <span class="keyword">if</span> (bundle != <span class="predefined-constant">null</span>) {
      <span class="keyword">try</span> {
        <span class="predefined-type">InputStream</span> in = bundle.openInputStream();
        <span class="predefined-type">Properties</span> properties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>();
        properties.load(in);
        <span class="keyword">return</span> properties;
      }
      <span class="keyword">catch</span> (<span class="exception">IOException</span> e) {
        context.log(<span class="predefined-type">Level</span>.SEVERE, <span class="string"><span class="delimiter">&quot;</span><span class="content">Could not load resource bundle</span><span class="delimiter">&quot;</span></span>, e);
      }
    }
    <span class="keyword">return</span> <span class="predefined-constant">null</span>;
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally let&#8217;s wrap up the bundle processing by looking at the <code>generateBundleClass</code> method which generates the
Java class:</p>
</div>
<div class="listingblock">
<div class="title">The <code>generateBundleClass</code> method</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">private</span> <span class="type">void</span> generateBundleClass(ProcessingContext context, <span class="predefined-type">Properties</span> properties, PackageElement pkgElt, <span class="predefined-type">String</span> bundleName) <span class="directive">throws</span> <span class="exception">IOException</span> {
    <span class="predefined-type">String</span> fqn = pkgElt.getQualifiedName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">.</span><span class="delimiter">&quot;</span></span> + bundleName;
    JavaFileObject source = context.createSourceFile(fqn, pkgElt);
    <span class="predefined-type">PrintWriter</span> writer = <span class="keyword">new</span> <span class="predefined-type">PrintWriter</span>(source.openWriter());
    writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">package </span><span class="delimiter">&quot;</span></span> + pkgElt.getQualifiedName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">;</span><span class="delimiter">&quot;</span></span>);
    writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">import examples.plugin.bundlegen.impl.BundleResolver;</span><span class="delimiter">&quot;</span></span>);
    writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">public class </span><span class="delimiter">&quot;</span></span> + bundleName + <span class="string"><span class="delimiter">&quot;</span><span class="content"> {</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">for</span> (<span class="predefined-type">String</span> key : properties.stringPropertyNames()) {
      writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">public static String </span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="content">() {</span><span class="delimiter">&quot;</span></span>);
      writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">return BundleResolver.resolve(</span><span class="delimiter">&quot;</span></span> + bundleName + <span class="string"><span class="delimiter">&quot;</span><span class="content">.class, </span><span class="char">\&quot;</span><span class="delimiter">&quot;</span></span> + key + <span class="string"><span class="delimiter">&quot;</span><span class="char">\&quot;</span><span class="content">);</span><span class="delimiter">&quot;</span></span>);
      writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>);
    }
    writer.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>);
    writer.close();
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation is quite straightforward, it creates a source file that returns a <code>JavaFileObject</code> whose
 writer is used to to print the source code of the bundle. The generated bundle class contains one method
 for each property of resource bundle.</p>
</div>

</div>
<div class="sect2">
<h3 id="_testing_the_plugin"><a class="anchor" href="#_testing_the_plugin"></a>Testing the plugin</h3>
<div class="paragraph">
<p>The last part of the <code>bundlegen</code> tutorial explains how to test a compilation plugin. We will
use create a mock application from its sources, this way we will test the plugin works from the source
files to the runtime.</p>
</div>
<div class="paragraph">
<p>We will study three tests each one focusing on a different aspect of the plugin usage:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>successful generation of the bundle class</p>
</li>
<li>
<p>runtime resolving of the bundle via the bundle class</p>
</li>
<li>
<p>correct error reporting when the bundle properties file does not exist</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_testing_the_bundle_generation"><a class="anchor" href="#_testing_the_bundle_generation"></a>Testing the bundle generation</h4>
<div class="paragraph">
<p>For this part, we will only use the Juzu compiler interface which is a wrapper of the underlying Java compiler
that can be used for writing unit tests. This wrapper allows us to compile an application from its sources. Our
test application contains the following package declaration:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@BundleGen</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">mybundle</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@Application</span>
<span class="keyword">package</span> <span class="namespace">examples.app1</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resource bundle properties contains a single property:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code>abc=def</code></pre>
</div>
</div>
<div class="paragraph">
<p>The sources of the application are located in the <em>resources</em> of the project, the only thing needed for the compiler
to resolve the source is the package of the application.</p>
</div>
<div class="listingblock">
<div class="title">The <code>testGenerateBundle</code> test</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Test</span>
  <span class="directive">public</span> <span class="type">void</span> testGenerateBundle() <span class="directive">throws</span> <span class="exception">Exception</span> {
    CompilerAssert&lt;<span class="predefined-type">File</span>, <span class="predefined-type">File</span>&gt; compilerAssert = compiler(<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.app1</span><span class="delimiter">&quot;</span></span>); <span class="comment">//<i class="conum">1</i></span>
    compilerAssert.assertCompile();                                        <span class="comment">//<i class="conum">2</i></span>
    ReadWriteFileSystem&lt;<span class="predefined-type">File</span>&gt; output = compilerAssert.getClassOutput();    <span class="comment">//<i class="conum">3</i></span>
    <span class="predefined-type">ClassLoader</span> loader = <span class="keyword">new</span> <span class="predefined-type">URLClassLoader</span>(<span class="keyword">new</span> <span class="predefined-type">URL</span><span class="type">[]</span>{ output.getURL() }); <span class="comment">//<i class="conum">4</i></span>
    <span class="predefined-type">Class</span>&lt;?&gt; bundleClass = loader.loadClass(<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.app1.mybundle</span><span class="delimiter">&quot;</span></span>);     <span class="comment">//<i class="conum">5</i></span>
    <span class="predefined-type">Method</span> m = bundleClass.getDeclaredMethod(<span class="string"><span class="delimiter">&quot;</span><span class="content">abc</span><span class="delimiter">&quot;</span></span>);                       <span class="comment">//<i class="conum">6</i></span>
    assertEquals(<span class="predefined-type">String</span>.class, m.getReturnType());
  }</code></pre>
</div>
</div>
<div class="colist arabic">

<table>
<tr>
<td><i class="conum">1</i></td>
<td>Create the compiler from the tested application package</td>
</tr>
<tr>
<td><i class="conum">2</i></td>
<td>Triggers compilation</td>
</tr>
<tr>
<td><i class="conum">3</i></td>
<td>Get the file system where the compiler created the compiled classes</td>
</tr>
<tr>
<td><i class="conum">4</i></td>
<td>Create a classloader for loading the bundle class</td>
</tr>
<tr>
<td><i class="conum">5</i></td>
<td>Load the bundle class</td>
</tr>
<tr>
<td><i class="conum">6</i></td>
<td>Assert the bundle class structure</td>
</tr>
</table>
</div>

</div>
<div class="sect3">
<h4 id="_testing_the_plugin_failure"><a class="anchor" href="#_testing_the_plugin_failure"></a>Testing the plugin failure</h4>
<div class="paragraph">
<p>In the previous section we tested the expected behavior of the plugin when it works, we also need to test
the behavior of the plugin when the bundle does not exist. The absence of the bundle properties file
will raise a compilation error with the <code>BUNDLE_NOT_FOUND</code> message code. By default the compiler will
use the message defined in the constant, however we can set the compiler in the special <code>formalErrorReporting</code>
mode that will use instead the message code value, making easier to write our test:</p>
</div>
<div class="listingblock">
<div class="title">The <code>testBundleNotFound</code> test</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Test</span>
  <span class="directive">public</span> <span class="type">void</span> testBundleNotFound() <span class="directive">throws</span> <span class="exception">Exception</span> {
    CompilerAssert&lt;<span class="predefined-type">File</span>, <span class="predefined-type">File</span>&gt; compilerAssert = compiler(<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.app2</span><span class="delimiter">&quot;</span></span>);
    compilerAssert.formalErrorReporting();                                     <span class="comment">//<i class="conum">1</i></span>
    <span class="predefined-type">List</span>&lt;CompilationError&gt; errors = compilerAssert.failCompile();              <span class="comment">//<i class="conum">2</i></span>
    assertEquals(<span class="integer">1</span>, errors.size());                                            <span class="comment">//<i class="conum">3</i></span>
    CompilationError error = errors.get(<span class="integer">0</span>);
    assertEquals(BundleGenMetaModelPlugin.BUNDLE_NOT_FOUND, error.getCode());  <span class="comment">//<i class="conum">4</i></span>
    assertEquals(<span class="predefined-type">Collections</span>.singletonList(<span class="string"><span class="delimiter">&quot;</span><span class="content">mybundle</span><span class="delimiter">&quot;</span></span>), error.getArguments());
    <span class="predefined-type">File</span> source = error.getSourceFile();
    assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">package-info.java</span><span class="delimiter">&quot;</span></span>, source.getName());
    assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">app2</span><span class="delimiter">&quot;</span></span>, source.getParentFile().getName());
  }</code></pre>
</div>
</div>
<div class="colist arabic">

<table>
<tr>
<td><i class="conum">1</i></td>
<td>Set the <code>formalErrorReporting</code> mode</td>
</tr>
<tr>
<td><i class="conum">2</i></td>
<td>We call now the <code>failCompile</code> that returns a list of compilation errors</td>
</tr>
<tr>
<td><i class="conum">3</i></td>
<td>We shall have a single error</td>
</tr>
<tr>
<td><i class="conum">4</i></td>
<td>Among other checks we assert that the <code>BUNDLE_NOT_FOUND</code> code was used</td>
</tr>
</table>
</div>

</div>
<div class="sect3">
<h4 id="_testing_the_bundle_resolution"><a class="anchor" href="#_testing_the_bundle_resolution"></a>Testing the bundle resolution</h4>
<div class="paragraph">
<p>Last but not last, we will test now the runtime behavior. A very simple controller will test the behavior
 at runtime:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Controller</span> {
  <span class="annotation">@View</span>
  <span class="directive">public</span> Response index() {
    <span class="keyword">return</span> Response.ok(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;abc&gt;</span><span class="delimiter">&quot;</span></span> + mybundle.abc() + <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/abc&gt;</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous test only required a compiler, now we need to execute our application. Juzu provides
a mocking framework that takes an application, compiles and then run it.</p>
</div>
<div class="listingblock">
<div class="title">The <code>testResolveBundle</code> test</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Test</span>
  <span class="directive">public</span> <span class="type">void</span> testResolveBundle() <span class="directive">throws</span> <span class="exception">Exception</span> {
    MockApplication&lt;<span class="predefined-type">File</span>&gt; application = application(InjectorProvider.GUICE, <span class="string"><span class="delimiter">&quot;</span><span class="content">examples.app1</span><span class="delimiter">&quot;</span></span>); <span class="comment">//<i class="conum">1</i></span>
    application.init();                                                                       <span class="comment">//<i class="conum">2</i></span>
    MockClient client = application.client();
    MockViewBridge view = client.render();                                                    <span class="comment">//<i class="conum">3</i></span>
    <span class="predefined-type">String</span> markup = view.assertStringResponse();
    assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;abc&gt;def&lt;/abc&gt;</span><span class="delimiter">&quot;</span></span>, markup);                                                   <span class="comment">//<i class="conum">4</i></span>
  }</code></pre>
</div>
</div>
<div class="colist arabic">

<table>
<tr>
<td><i class="conum">1</i></td>
<td>Create a mock application</td>
</tr>
<tr>
<td><i class="conum">2</i></td>
<td>The init step compiles and starts the application</td>
</tr>
<tr>
<td><i class="conum">3</i></td>
<td>Render the application, this invokes the <code>index</code> method of the application</td>
</tr>
<tr>
<td><i class="conum">4</i></td>
<td>Assert the returned application markup is correct</td>
</tr>
</table>
</div>

</div>

</div>

</div>
</div>

<h1 id="_metrics_plugin_tutorial" class="sect0"><a class="anchor" href="#_metrics_plugin_tutorial"></a>Metrics plugin tutorial</h1>
<div class="paragraph">
<p>The Metrics plugin tutorial provides guidance for the implementation of a Juzu service. This plugin provides an
integration of the <a href="http://metrics.codahale.com">Metrics</a> library in Juzu. Metrics is an easy to use library for reporting
and publishing metrics.</p>
</div>
<div class="paragraph">
<p>In this section we will study three Juzu runtime aspects:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>creation of a Juzu service</p>
</li>
<li>
<p>intercepting a Juzu request</p>
</li>
<li>
<p>binding a bean in the <em>IOC</em> container</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_creating_a_juzu_service"><a class="anchor" href="#_creating_a_juzu_service"></a>Creating a Juzu service</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Juzu service is a class extending the <code>juzu.impl.plugin.application.ApplicationService</code> abstract class. The
service must be declared in a +META-INF/services/juzu.impl.plugin.application.ApplicationService_ file:</p>
</div>
<div class="listingblock">
<div class="title">The <code>META-INF/services/juzu.impl.plugin.application.ApplicationService</code> service declaration</div>
<div class="content monospaced">
<pre>examples.plugin.metrics.MetricsService</pre>
</div>
</div>
<div class="paragraph">
<p>Our service constructor must be a public no argument constructor, it calls the super constructor with the
service name <em>metrics</em>:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="directive">public</span> MetricsService() {
    <span class="local-variable">super</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">metrics</span><span class="delimiter">&quot;</span></span>);
    registry = <span class="keyword">new</span> MetricRegistry();
    responses = registry.timer(<span class="string"><span class="delimiter">&quot;</span><span class="content">juzu.responses</span><span class="delimiter">&quot;</span></span>);
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor initializes two fields:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>the <code>registry</code> field, a Metrics registry that holds all the metrics, this registry will be bound in the IOC container
so an application or another service can be injected with this registry for publishing custom metrics</p>
</li>
<li>
<p>the <code>responses</code> field, a Metrics timer, bound in registry that will accumulate request statistics</p>
</li>
</ul>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_service_initialization"><a class="anchor" href="#_service_initialization"></a>Service initialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After the service is created, Juzu will call its <code>init</code> method to perform the initialization step. The <code>init</code>
method can return a <code>ServiceDescriptor</code> that will instruct Juzu to load the service. The service can chose
to return null instead of the descriptor, the null value tells Juzu to discard the service instead.</p>
</div>
<div class="paragraph">
<p>The service descriptor contains a list of <code>BeanDescriptor</code> classes: this is the list of the beans the service
 wants to register in the IOC container. In our case we want to expose the Metrics registry as a singleton
 bean so it can be injected in the whole application:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Override</span>
  <span class="directive">public</span> ServiceDescriptor init(ServiceContext context) <span class="directive">throws</span> <span class="exception">Exception</span> {
    <span class="predefined-type">Provider</span>&lt;MetricRegistry&gt; registryProvider = <span class="keyword">new</span> <span class="predefined-type">Provider</span>&lt;MetricRegistry&gt;() {
      <span class="annotation">@Override</span>
      <span class="directive">public</span> MetricRegistry get() {
        <span class="keyword">return</span> registry;
      }
    }; <span class="comment">//<i class="conum">1</i></span>
    <span class="predefined-type">BeanDescriptor</span> registryDescriptor = <span class="predefined-type">BeanDescriptor</span>.createFromProvider(  <span class="comment">//<i class="conum">2</i></span>
        MetricRegistry.class,
        Scope.SINGLETON,
        <span class="predefined-type">Collections</span>.&lt;<span class="predefined-type">Annotation</span>&gt;emptyList(),
        registryProvider);
    <span class="keyword">return</span> <span class="keyword">new</span> ServiceDescriptor(<span class="predefined-type">Arrays</span>.asList(registryDescriptor));        <span class="comment">//<i class="conum">3</i></span>
  }</code></pre>
</div>
</div>
<div class="colist arabic">

<table>
<tr>
<td><i class="conum">1</i></td>
<td>Create a <code>javax.inject.Provider</code> that wraps the <code>registry</code> field</td>
</tr>
<tr>
<td><i class="conum">2</i></td>
<td>Create a singleton bean descriptor</td>
</tr>
<tr>
<td><i class="conum">3</i></td>
<td>Return the service descriptor with the registry bean</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After the service is initialized, the service will be <em>started</em>, this event can be intercepted with the
<code>javax.annotation.PostConstruct</code> callback: our service will use it to bind the registry into the static
<code>SharedMetricRegistries</code> exposed by Metrics:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@PostConstruct</span>
  <span class="directive">public</span> <span class="type">void</span> start() {
    SharedMetricRegistries.add(application.getPackageName(), registry);
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The registry is bound under the application package name, making sure that registries will be namespaced
correctly to avoid collisions.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_intercepting_the_request"><a class="anchor" href="#_intercepting_the_request"></a>Intercepting the request</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have now a fully initiliazed Metrics registry and timer, let&#8217;s see how to intercept the Juzu requests
to collect statistics in this timer. Intercepting a request is done by implementing the <code>juzu.impl.request.RequestFilter</code>
interface for a specific request stage.</p>
</div>
<div class="paragraph">
<p>The application request is indeed decomposed into four stages:</p>
</div>
<div class="ulist">

<ul>
<li>
<p><em>unmarshalling</em> : unmarshalls the request entity when there is one</p>
</li>
<li>
<p><em>handler</em>       : determine the handler arguments and get the application handler from the IOC container</p>
</li>
<li>
<p><em>lifecycle</em>     : trigger the controller lifecycle and calls the <code>juzu.request.RequestLifeCycle</code> interface when necessary</p>
</li>
<li>
<p><em>invoke</em>        : performs the handler method invocation on the controller</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our service can use mostly any of these stage as it just wants to count the number of requests, so it will use
the <em>invoke</em> stage and thus our service implements the <code>RequestFilter&lt;Stage.Invoke&gt;</code> interface:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Override</span>
  <span class="directive">public</span> Response handle(Stage.Invoke argument) {
    <span class="directive">final</span> <span class="predefined-type">Timer</span>.Context context = responses.time();
    <span class="keyword">try</span> {
      <span class="keyword">return</span> argument.invoke();
    } <span class="keyword">finally</span> {
      context.stop();
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation is quite trivial, it uses the <code>responses</code> timer to collect the request statistic.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_testing_the_plugin_2"><a class="anchor" href="#_testing_the_plugin_2"></a>Testing the plugin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will test the plugin via the <code>MockApplication</code> object provided by Juzu, the test application is quite simple with
a single controller:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Controller</span> {

  <span class="annotation">@Inject</span>
  <span class="directive">public</span> Controller(MetricRegistry registry) {
    registry.meter(<span class="string"><span class="delimiter">&quot;</span><span class="content">custom</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="annotation">@View</span>
  <span class="directive">public</span> Response index() {
    <span class="keyword">return</span> Response.ok(<span class="string"><span class="delimiter">&quot;</span><span class="content">ok</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
<div class="ulist">

<ul>
<li>
<p>the constructor is injected with the registry and it publishes a custom meter</p>
</li>
<li>
<p>the <code>index</code> method handles the application request and returns a simple <em>ok</em> value</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Our test will assert three things:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>the Metrics registry is published in the <code>SharedMetricRegistries</code></p>
</li>
<li>
<p>the Metrics registry recorded the request succesfully</p>
</li>
<li>
<p>the Metrics registry can be used by the application</p>
</li>
</ul>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="annotation">@Test</span>
  <span class="directive">public</span> <span class="type">void</span> testTimer() <span class="directive">throws</span> <span class="exception">Exception</span> {
    SharedMetricRegistries.clear();                                                             <span class="comment">//<i class="conum">1</i></span>
    MockApplication&lt;<span class="predefined-type">File</span>&gt; application = application(InjectorProvider.GUICE, <span class="string"><span class="delimiter">&quot;</span><span class="content">examples.metrics</span><span class="delimiter">&quot;</span></span>);<span class="comment">//<i class="conum">2</i></span>
    application.init();
    MockClient client = application.client();
    MockViewBridge view = client.render();                                                      <span class="comment">//<i class="conum">3</i></span>
    assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">ok</span><span class="delimiter">&quot;</span></span>, view.assertStringResponse());
    assertEquals(<span class="predefined-type">Collections</span>.singleton(<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.metrics</span><span class="delimiter">&quot;</span></span>), SharedMetricRegistries.names());    <span class="comment">//<i class="conum">4</i></span>
    MetricRegistry registry = SharedMetricRegistries.getOrCreate(<span class="string"><span class="delimiter">&quot;</span><span class="content">examples.metrics</span><span class="delimiter">&quot;</span></span>);
    <span class="predefined-type">Timer</span> timer = registry.getTimers().get(<span class="string"><span class="delimiter">&quot;</span><span class="content">juzu.responses</span><span class="delimiter">&quot;</span></span>);                                   <span class="comment">//<i class="conum">5</i></span>
    assertEquals(<span class="integer">1</span>, timer.getCount());
    Meter meter = registry.getMeters().get(<span class="string"><span class="delimiter">&quot;</span><span class="content">custom</span><span class="delimiter">&quot;</span></span>);                                           <span class="comment">//<i class="conum">6</i></span>
    assertNotNull(meter);
  }</code></pre>
</div>
</div>
<div class="colist arabic">

<table>
<tr>
<td><i class="conum">1</i></td>
<td>Clear the <code>SharedMetricRegistries</code></td>
</tr>
<tr>
<td><i class="conum">2</i></td>
<td>Create the mock application</td>
</tr>
<tr>
<td><i class="conum">3</i></td>
<td>Invoke the application</td>
</tr>
<tr>
<td><i class="conum">4</i></td>
<td>Check our registry was published under the application package name</td>
</tr>
<tr>
<td><i class="conum">5</i></td>
<td>Get the timer and check it recorded the statistic</td>
</tr>
<tr>
<td><i class="conum">6</i></td>
<td>Check the application used the registry via injection succesfully</td>
</tr>
</table>
</div>

</div>
</div>


</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-04-24 14:06:16 CEST
</div>
</div>
</body>
</html>