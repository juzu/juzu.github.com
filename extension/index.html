<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.3">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Juzu Extension Guide</title>
<link rel="stylesheet" href="./rocket-panda.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.1.0/css/font-awesome.min.css">
<style>
.CodeRay {
  background-color: hsl(0,0%,95%);
  border: 1px solid silver;
  color: black;
}
.CodeRay pre {
  margin: 0px;
}

span.CodeRay { white-space: pre; border: 0px; padding: 2px; }

table.CodeRay { border-collapse: collapse; width: 100%; padding: 2px; }
table.CodeRay td { padding: 2px 4px; vertical-align: top; }

.CodeRay .line-numbers {
  background-color: hsl(180,65%,90%);
  color: gray;
  text-align: right;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}
.CodeRay .line-numbers a {
  background-color: hsl(180,65%,90%) !important;
  color: gray !important;
  text-decoration: none !important;
}
.CodeRay .line-numbers a:target { color: blue !important; }
.CodeRay .line-numbers .highlighted { color: red !important; }
.CodeRay .line-numbers .highlighted a { color: red !important; }
.CodeRay span.line-numbers { padding: 0px 4px; }
.CodeRay .line { display: block; float: left; width: 100%; }
.CodeRay .code { width: 100%; }

.CodeRay .debug { color: white !important; background: blue !important; }

.CodeRay .annotation { color:#007 }
.CodeRay .attribute-name { color:#b48 }
.CodeRay .attribute-value { color:#700 }
.CodeRay .binary { color:#509 }
.CodeRay .char .content { color:#D20 }
.CodeRay .char .delimiter { color:#710 }
.CodeRay .char { color:#D20 }
.CodeRay .class { color:#B06; font-weight:bold }
.CodeRay .class-variable { color:#369 }
.CodeRay .color { color:#0A0 }
.CodeRay .comment { color:#777 }
.CodeRay .comment .char { color:#444 }
.CodeRay .comment .delimiter { color:#444 }
.CodeRay .complex { color:#A08 }
.CodeRay .constant { color:#036; font-weight:bold }
.CodeRay .decorator { color:#B0B }
.CodeRay .definition { color:#099; font-weight:bold }
.CodeRay .delimiter { color:black }
.CodeRay .directive { color:#088; font-weight:bold }
.CodeRay .doc { color:#970 }
.CodeRay .doc-string { color:#D42; font-weight:bold }
.CodeRay .doctype { color:#34b }
.CodeRay .entity { color:#800; font-weight:bold }
.CodeRay .error { color:#F00; background-color:#FAA }
.CodeRay .escape  { color:#666 }
.CodeRay .exception { color:#C00; font-weight:bold }
.CodeRay .float { color:#60E }
.CodeRay .function { color:#06B; font-weight:bold }
.CodeRay .global-variable { color:#d70 }
.CodeRay .hex { color:#02b }
.CodeRay .imaginary { color:#f00 }
.CodeRay .include { color:#B44; font-weight:bold }
.CodeRay .inline { background-color: hsla(0,0%,0%,0.07); color: black }
.CodeRay .inline-delimiter { font-weight: bold; color: #666 }
.CodeRay .instance-variable { color:#33B }
.CodeRay .integer  { color:#00D }
.CodeRay .key .char { color: #60f }
.CodeRay .key .delimiter { color: #404 }
.CodeRay .key { color: #606 }
.CodeRay .keyword { color:#080; font-weight:bold }
.CodeRay .label { color:#970; font-weight:bold }
.CodeRay .local-variable { color:#963 }
.CodeRay .namespace { color:#707; font-weight:bold }
.CodeRay .octal { color:#40E }
.CodeRay .operator { }
.CodeRay .predefined { color:#369; font-weight:bold }
.CodeRay .predefined-constant { color:#069 }
.CodeRay .predefined-type { color:#0a5; font-weight:bold }
.CodeRay .preprocessor { color:#579 }
.CodeRay .pseudo-class { color:#00C; font-weight:bold }
.CodeRay .regexp .content { color:#808 }
.CodeRay .regexp .delimiter { color:#404 }
.CodeRay .regexp .modifier { color:#C2C }
.CodeRay .regexp { background-color:hsla(300,100%,50%,0.06); }
.CodeRay .reserved { color:#080; font-weight:bold }
.CodeRay .shell .content { color:#2B2 }
.CodeRay .shell .delimiter { color:#161 }
.CodeRay .shell { background-color:hsla(120,100%,50%,0.06); }
.CodeRay .string .char { color: #b0b }
.CodeRay .string .content { color: #D20 }
.CodeRay .string .delimiter { color: #710 }
.CodeRay .string .modifier { color: #E40 }
.CodeRay .string { background-color:hsla(0,100%,50%,0.05); }
.CodeRay .symbol .content { color:#A60 }
.CodeRay .symbol .delimiter { color:#630 }
.CodeRay .symbol { color:#A60 }
.CodeRay .tag { color:#070 }
.CodeRay .type { color:#339; font-weight:bold }
.CodeRay .value { color: #088; }
.CodeRay .variable  { color:#037 }

.CodeRay .insert { background: hsla(120,100%,50%,0.12) }
.CodeRay .delete { background: hsla(0,100%,50%,0.12) }
.CodeRay .change { color: #bbf; background: #007; }
.CodeRay .head { color: #f8f; background: #505 }
.CodeRay .head .filename { color: white; }

.CodeRay .delete .eyecatcher { background-color: hsla(0,100%,50%,0.2); border: 1px solid hsla(0,100%,45%,0.5); margin: -1px; border-bottom: none; border-top-left-radius: 5px; border-top-right-radius: 5px; }
.CodeRay .insert .eyecatcher { background-color: hsla(120,100%,50%,0.2); border: 1px solid hsla(120,100%,25%,0.5); margin: -1px; border-top: none; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }

.CodeRay .insert .insert { color: #0c0; background:transparent; font-weight:bold }
.CodeRay .delete .delete { color: #c00; background:transparent; font-weight:bold }
.CodeRay .change .change { color: #88f }
.CodeRay .head .head { color: #f4f }

</style>
</head>
<body class="book toc2">
<div id="header">
<h1>Juzu Extension Guide</h1>
<span id="author">Julien Viet</span><br>
<span id="email"><a href="http://www.julienviet.com">http://www.julienviet.com</a></span><br>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ol type="none" class="sectlevel0">
<li><a href="#_value_types">Value types</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_implementing_the_code_valuetype_code">Implementing the <code>ValueType</code></a></li>
<li><a href="#_declaring_the_code_valuetype_code">Declaring the <code>ValueType</code></a></li>
</ol>
</li>
<li><a href="#_entity_processing">Entity processing</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_entity_unmarshallers">Entity unmarshallers</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_implementing_an_unmarshaller">Implementing an unmarshaller</a></li>
<li><a href="#_declaring_an_unmarshaller">Declaring an unmarshaller</a></li>
</ol>
</li>
<li><a href="#_entity_marshallers">Entity marshallers</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_implementing_a_marshaller">Implementing a marshaller</a></li>
<li><a href="#_declaring_a_marshaller">Declaring a marshaller</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#templatespi">Templating SPI</a></li>
<li>
<ol type="none" class="sectlevel1">
<li><a href="#_compiling_a_groovy_template">Compiling a Groovy template</a></li>
<li><a href="#_type_safe_url_resolution">Type safe URL resolution</a></li>
<li><a href="#_template_service_provider_interface">Template Service Provider Interface</a></li>
<li>
<ol type="none" class="sectlevel2">
<li><a href="#_template_providers">Template providers</a></li>
<li><a href="#_template_stub">Template stub</a></li>
</ol>
</li>
<li><a href="#_template_at_work">Template at work</a></li>
<li><a href="#_qualified_template_class">Qualified template class</a></li>
</ol>
</li>
</ol>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Juzu is a web framework based on MVC concepts for developing applications. Juzu is an
open source project developed on <a href="https://github.com/juzu/juzu">GitHub</a> licensed under the
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2 License</a>.</p>
</div>

</div>
</div>
<h1 id="_value_types" class="sect0"><a class="anchor" href="#_value_types"></a>Value types</h1>
<div class="paragraph">
<p>Value types is a Juzu plugin for dealing with controller parameters that can trivially be converted from and to strings.
In this section we will explain how the <code>juzu.impl.value.ValueType</code> interface works.</p>
</div>
<div class="sect1">
<h2 id="_implementing_the_code_valuetype_code"><a class="anchor" href="#_implementing_the_code_valuetype_code"></a>Implementing the <code>ValueType</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">The ValueType abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">ValueType</span>&lt;T&gt; {

  <span class="comment">/**
   * The list of java classes this implementation can handle.
   *
   * @return the list of types.
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getTypes();

  <span class="comment">/**
   * Parse a string and returns the corresponding value type.
   *
   * @param element the element annotations
   * @param s the string to parse
   * @return the corresponding value
   * @throws java.lang.Exception any exception preventing the parse to succeed
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> T parse(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">String</span> s) <span class="directive">throws</span> <span class="exception">Exception</span>;

  <span class="comment">/**
   * Format a value and returns the corresponding string.
   *
   * @param element the element annotations
   * @param value the value to format
   * @return the corresponding string
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> format(<span class="predefined-type">AnnotatedElement</span> element, T value);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The base implementation should extend the <code>ValueType</code> interface and provide a class type for the <code>&lt;T&gt;</code> generic parameter
of the class:</p>
</div>
<div class="listingblock">
<div class="title">The ValueType abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">DateValueType</span> <span class="directive">extends</span> ValueType&lt;java.util.Date&gt; {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getTypes()</code> interface should return the class type the value type is converting:</p>
</div>
<div class="listingblock">
<div class="title">The getTypes implementation</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Class</span>&lt;?&gt;&gt; getTypes() {
  <span class="keyword">return</span> <span class="predefined-type">Collections</span>.singleton(java.util.Date.class);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">

several types can be returned by the method, this is used by the <code>ValueType</code> that handle primitive types such
as <code>int</code>, <code>boolean</code>, etc&#8230;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally the <code>parse</code> and <code>format</code> methods need to be implemented too:</p>
</div>
<div class="listingblock">
<div class="title">The parse and format implementations</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="predefined-type">Date</span> parse(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">String</span> s) <span class="directive">throws</span> <span class="exception">ParseException</span> {
  <span class="keyword">return</span> getSimpleDateFormat(element).parse(s);
}

<span class="directive">public</span> <span class="predefined-type">String</span> format(<span class="predefined-type">AnnotatedElement</span> element, <span class="predefined-type">Date</span> value) {
  <span class="keyword">return</span> getSimpleDateFormat(element).format(value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>parse</code> and <code>format</code> methods provides access to the <code>element</code> that is converted, the purpose of those
objects is to provide access to optional annotation the element may have. Such annotations can be used by the
value type for doing the conversion:</p>
</div>
<div class="listingblock">
<div class="title">Using the annotated element for configuring the SimpleDateFormat object</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">private</span> <span class="predefined-type">SimpleDateFormat</span> getSimpleDateFormat(<span class="predefined-type">AnnotatedElement</span> element) {
  <span class="predefined-type">Format</span> format = element.getAnnotation(<span class="predefined-type">Format</span>.class);
  <span class="keyword">return</span> format != <span class="predefined-constant">null</span> ? <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>(format.value()) : <span class="keyword">new</span> <span class="predefined-type">SimpleDateFormat</span>();
}</code></pre>
</div>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_declaring_the_code_valuetype_code"><a class="anchor" href="#_declaring_the_code_valuetype_code"></a>Declaring the <code>ValueType</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value types are declared in the <code>META-INF/services/juzu.impl.value.ValueType</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>
</div>

<h1 id="_entity_processing" class="sect0"><a class="anchor" href="#_entity_processing"></a>Entity processing</h1>
<div class="paragraph">
<p>Juzu allows the application to interact with request and response entities with the <code>juzu.request.ClientContext</code> and
the <code>juzu.Response.Body</code> objects. Those objects are binary data (or character data) oriented and provide a low
 level interface for reading or writing request entities.</p>
</div>
<div class="paragraph">
<p>Juzu provides also a plugable higher level API for dealing with request entities such as <em>File Upload</em> or <em>Json</em>. In this
section we will explain how to implement such plugins.</p>
</div>
<div class="sect1">
<h2 id="_entity_unmarshallers"><a class="anchor" href="#_entity_unmarshallers"></a>Entity unmarshallers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity unmarshallers are plugins that decodes a <code>juzu.request.ClientContext</code> into a set of arguments that will be
used by Juzu when invoking the controller. The unmarshaller can manipulate those arguments, usually reading the
request entity. The <code>juzu.impl.request.EntityUnmarshaller</code> abstract class has two methods to implement, let&#8217;s review
them.</p>
</div>
<div class="listingblock">
<div class="title">The EntityUnmarshaller abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">EntityUnmarshaller</span> {

  <span class="comment">/**
   * Decide wether or not this reader accept to read the specified &lt;code&gt;mediaType&lt;/code&gt; argument.
   *
   * @param mediaType the media type to test
   * @return true if the media type is accepted
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">boolean</span> accept(<span class="predefined-type">String</span> mediaType);

  <span class="comment">/**
   * Unmarshall the entity from the {@link juzu.request.ClientContext}. This unmarshaller can modify the
   * request control arguments:
   * &lt;ul&gt;
   *   &lt;li&gt;the contextual arguments can be iterated and the value updated&lt;/li&gt;
   *   &lt;li&gt;the parameter arguments map can be freely modified&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param mediaType the request media type
   * @param context the client context for reading the entity
   * @param contextualArguments the contextual arguments
   * @param parameterArguments the contextual parameters
   * @throws IOException anything preventing the read operation to succeed
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> unmarshall(
      <span class="predefined-type">String</span> mediaType,
      ClientContext context,
      <span class="predefined-type">Iterable</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;ContextualParameter, <span class="predefined-type">Object</span>&gt;&gt; contextualArguments,
      <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, RequestParameter&gt; parameterArguments) <span class="directive">throws</span> <span class="exception">IOException</span>;

}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_an_unmarshaller"><a class="anchor" href="#_implementing_an_unmarshaller"></a>Implementing an unmarshaller</h3>
<div class="paragraph">
<p>The <code>accept</code> method is quite simple to implement, it should return true when the unmarshaller wants to unmarshall
the incoming request, for instance:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> accept(<span class="predefined-type">String</span> mediaType) {
  <span class="keyword">return</span> mediaType.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>unmarshall</code> method will be invoked when the <code>accept</code> method returns true. At this moment, the unmarshaller should
read the entity data using the <code>ClientContext</code> interface and update the request arguments. There are two kinds of
request arguments that can be modified:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>parameter arguments using the <code>parameterArguments</code> method parameter</p>
</li>
<li>
<p>contextual arguments using the <code>contextualArguments</code> method parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Parameter arguments is a mutable map that provides string parameter values, those parameters are used by Juzu at
a later stage when invoking the controller handler. Those parameters can be used as is, or can be transformed into
other types via the <code>ValueType</code> extension or the <code>@Mapped</code> bean mapping. The <em>File Upload</em> unmarshaller
will create parameter arguments when reading the file upload form.</p>
</div>
<div class="paragraph">
<p>Contextual arguments are any controller argument that are not parameter arguments (i.e any type that is not a <code>ValueType</code>
or annotated with <code>@Mapped</code>). The unmarshall method can iterate over such arguments and modify them freely. The
<code>ContextualParameter</code> object provides the <em>name</em>, <em>class+ and _generic type+ of the argument. Those shall be used by
 the unmarshaller to properly modify the arguments. The _File Upload</em> unmarshaller will look at the contextual
 arguments having the type <code>org.apache.commons.fileupload.FileItem</code> and the right argument name to do the match.</p>
</div>

</div>
<div class="sect2">
<h3 id="_declaring_an_unmarshaller"><a class="anchor" href="#_declaring_an_unmarshaller"></a>Declaring an unmarshaller</h3>
<div class="paragraph">
<p>Unmarshallers are declared in the <code>META-INF/services/juzu.impl.request.EntityUnmarshaller</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_entity_marshallers"><a class="anchor" href="#_entity_marshallers"></a>Entity marshallers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Entity marshallers are plugins that encodes an object, usually returned by a controller handler into binary data
sent with the response. The <code>juzu.impl.request.EntityMarshaller</code> abstract class has a single method <em>marshall</em>
to implement, let&#8217;s review it.</p>
</div>
<div class="sect2">
<h3 id="_implementing_a_marshaller"><a class="anchor" href="#_implementing_a_marshaller"></a>Implementing a marshaller</h3>
<div class="listingblock">
<div class="title">The EntityMarshaller abstract class</div>
<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">EntityMarshaller</span> {

  <span class="comment">/**
   * Marshall the object for the specified &lt;code&gt;mimeType&lt;/code&gt; or return null.
   *
   * @param mimeType the mime type to test
   * @param annotations the contextual annotations
   * @param object the object to marshall  @return the corresponding streamable
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> Streamable marshall(<span class="predefined-type">String</span> mimeType, <span class="predefined-type">AnnotatedElement</span> annotations, <span class="predefined-type">Object</span> object);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The marshall method will be invoked by Juzu, when a controller returns an unknown object response (i.e an object
that does not inherit from the <code>juzu.Response</code> class). The marshall method can either return a null response to
signal that it cannot handle it or a <code>Streamable</code> implementation that will be used to create a <code>juzu.Response</code>.</p>
</div>

</div>
<div class="sect2">
<h3 id="_declaring_a_marshaller"><a class="anchor" href="#_declaring_a_marshaller"></a>Declaring a marshaller</h3>
<div class="paragraph">
<p>Unmarshallers are declared in the <code>META-INF/services/juzu.impl.request.EntityMarshaller</code> file, such plugins are
loaded via the <code>java.util.ServiceLoader</code> interface.</p>
</div>

</div>

</div>
</div>

<h1 id="templatespi" class="sect0"><a class="anchor" href="#templatespi"></a>Templating SPI</h1>
<div class="paragraph">
<p>This chapter dives into the template life cycle from the compilation time to the run time. We will describe the
template Service Provider Interface (SPI), the SPI is designed to make Juzu templating extensible and integrating
template engines in Juzu. This chapter is optional is you are only writing ab application with Juzu, however it is
a must read if you want to know more Juzu internals or if you want to understand how to integrate a
template engine in Juzu.</p>
</div>
<div class="paragraph">
<p>When a Juzu application is compiled, the Juzu annotation processor detects the <code>@Path</code> annotations and triggers
the compilation of the related templates. The template compilation can be split in two parts:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Generating the template companion class that inherits the <code>juzu.template.Template</code> class. This part is generic
and works with any templating system, it is entirely managed by Juzu.</p>
</li>
<li>
<p>Processing the template file, this task is delegated to the <code>TemplateProvider</code> interface and is extensible.
The provider allows to have several templating system in Juzu and decouples the template compilation process
from the details of the templating engine.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_compiling_a_groovy_template"><a class="anchor" href="#_compiling_a_groovy_template"></a>Compiling a Groovy template</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s study an example with the Groovy template at compilation time.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/templatespi/lifecycle1.png" alt="Life cycle" width="700">
</div>
<div class="title">Figure 1. Compiling a Groovy template</div>
</div>
<div class="paragraph">
<p>When the Java compiler is invoked, the following steps are executed</p>
</div>
<div class="olist arabic">

<ol class="arabic">
<li>
<p>The Java compiler triggers the Juzu annotation processor when it finds the <code>@Path</code> annotation</p>
</li>
<li>
<p>Juzu resolves the relative path to the <code>templates</code> package of the application</p>
<div class="olist loweralpha">

<ol class="loweralpha" type="a">
<li>
<p>When the template cannot be resolved a compilation error is triggered</p>
</li>
<li>
<p>Otherwise the template is loaded</p>
</li>
</ol>
</div>

</li>
<li>
<p>The template provider is looked up according to the file name extension, it generates the <em>index</em>.groovy_ source file</p>
</li>
<li>
<p>Juzu creates the <code>index</code> class that extends the <code>juzu.template.Template</code> class annotated by the <code>@Path("index.gtmpl")</code> annotation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After that the only remaining part is to compile the <em>index</em>.groovy_ source to a class. It can be achieved either at build time
using the <em>groovyc</em> compiler or at load time when the <code>index</code> template is loaded using a <code>GroovyClassLoader</code>. The former
approach makes the build a bit more complex (but not much as Groovy compilation is fairly well supported in build systems or IDEs)
as it requires to run a Groovy compilation but it will perform additional validation of the template as well as reduce the load
time of the template. The later approach will detect any compilation error (such as Groovy syntax error) at runtime
and the <em>index</em>.groovy_ compilation will take a few milliseconds.</p>
</div>
<div class="paragraph">
<p>This flexibility allows to use the lazy approach during development and when the application is released then the Groovy compiler
can be used to compile the <em>index</em>.groovy_.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_type_safe_url_resolution"><a class="anchor" href="#_type_safe_url_resolution"></a>Type safe URL resolution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy templates provides the <code>@{&#8230;}</code> syntax for generating URL from the application controllers. This section gives
an overview of the underlying resolution mechanism.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/templatespi/lifecycle2.png" alt="URL resolution" width="750">
</div>
<div class="title">Figure 2. Template URL resolution during compilation</div>
</div>
<div class="ulist">

<ul>
<li>
<p>Parse: the template is parsed into its model representation</p>
</li>
<li>
<p>Resolve: the <code>index</code> link is resolved againt the controller meta model</p>
</li>
<li>
<p>Validate: the <code>index</code> link is validated</p>
</li>
<li>
<p>Emit: the corresponding <em>index</em>.groovy_ file is emitted and save on the class output</p>
</li>
<li>
<p>Compile: the Groovy source is compiled into a class by the <em>groovyc</em> compiler (this part is done after <em>javac</em>)</p>
</li>
</ul>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_template_service_provider_interface"><a class="anchor" href="#_template_service_provider_interface"></a>Template Service Provider Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Juzu provides a Service Provider Interface (SPI) for integrating thirdparty template engine. Actually all template
system are integrated with the SPI. We will study briefly the integration points so you can integrate a template engine
of your choice in Juzu.</p>
</div>
<div class="sect2">
<h3 id="_template_providers"><a class="anchor" href="#_template_providers"></a>Template providers</h3>
<div class="paragraph">
<p>The <code>juzu.impl.template.spi.TemplateProvider</code> is the main entry point when a templating system is integrated. The
provider is triggered during the compilation phase by the APT system built into the Java compiler.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">TemplateProvider</span>&lt;M <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt; {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The provider must declare the template model <code>&lt;M&gt;</code> generic type, this type must be a serializable as Juzu will sometimes
write template models on the disk during the compilation. This usually happens only in Eclipse due its incremental
compiler architecture. The type specified by the provider is privately managed (i.e it is opaque for Juzu) and it
symbolizes an internal representation of the parsed source (usually an Abstract Syntax Tree), it will be used in
various methods of the provider.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a review of the methods of this class to have a better understanding.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Returns the template source extension without the dot recognised by
   * this provider. For instance it should return &lt;code&gt;gtmpl&lt;/code&gt;
   * for groovy templates.
   *
   * @return the source extension
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> getSourceExtension();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getSourceExtension()</code> method is used to determine what file extension the provider can compile. The implementation
 should return a constant value, for instance the Groovy provide simply returns the <code>gtmpl</code> value.</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Parse the provided char sequence and return the corresponding template model.
   *
   * @param context the parse context
   * @param source the source to parse
   * @return the corresponding template model
   * @throws TemplateException any template related exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> M parse(
      ParseContext context,
      <span class="predefined-type">CharSequence</span> source) <span class="directive">throws</span> TemplateException;

  <span class="comment">/**
   * Process the template.
   *
   * @param context the process context
   * @param templateModel  the template to process
   * @throws TemplateException any template related exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> process(
      ProcessContext context,
      TemplateModel&lt;M&gt; templateModel) <span class="directive">throws</span> TemplateException;

  <span class="comment">/**
   * Provide an opportunity for emitting a file on the disk.
   *
   * @param context the emit context
   * @param templateModel the template
   * @throws TemplateException any template related exception
   * @throws IOException any io exception
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> emit(
      EmitContext context,
      TemplateModel&lt;M&gt; templateModel) <span class="directive">throws</span> TemplateException, <span class="exception">IOException</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>parse</code>, <code>process</code> and <code>emit</code> methods care about transforming the template source to its final representation:
the compiled template.</p>
</div>
<div class="ulist">

<ul>
<li>
<p>The <code>parse</code> method is invoked with the content of the template and returns a template model. The representation returned
by the parse method is a parsed representation of the template source. If a parsing error occurs the method can throw
a <code>TemplateException</code>.</p>
</li>
<li>
<p>The <code>process</code> method is invoked after the template is parsed with the necessary context for performing further
processing of the template, for instance the Groovy templating engine performs the resolution of type safe URLs or type
safe parameters declaration at this moment. During the process:</p>
<div class="ulist">

<ul>
<li>
<p>The provider can resolve other templates using the <code>ProcessContext</code>, if the template to resolve is not
yet loaded it will trigger the <code>parse</code>/<code>process</code>/<code>emit</code> lifecycle, it if was already processed the template
is simply returned</p>
</li>
<li>
<p>The implementation can resolve controller methods and translate them into method invocation, this is used for
checking type safe URL and translating them into controller companion invocation</p>
</li>
<li>
<p>The <code>juzu.impl.template.spi.TemplateModel</code> argument models the template, it has several fields such as the underlying
model or the template path</p>
</li>
<li>
<p>The implementation can declare type safe parameters using the <code>TemplateModel#addParameter(String)</code> method. The declared
parameters will be generated on the <code>juzu.template.Template</code> subclass</p>
</li>
</ul>
</div>

</li>
<li>
<p>The <code>emit</code> method is invoked when the template processing is over. The <code>EmitContext</code> interface can be used
to create resources during this round.</p>
</li>
</ul>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Return the template stub type.
   *
   * @return the template stub class
   */</span>
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> TemplateStub&gt; getTemplateStubType();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally the <code>getTemplateStubType()</code> returns the type of a java class that will be used for creating a template stub.
For each template, a stub is created, the stub is responsible for loading the template at runtime, i.e the original
template or the compiled template that may have been generated during compilation during the <code>emit</code> callback.</p>
</div>

</div>
<div class="sect2">
<h3 id="_template_stub"><a class="anchor" href="#_template_stub"></a>Template stub</h3>
<div class="paragraph">
<p>Template stubs are java classes created by Juzu for managing a template at runtime on behalf of the provider.
Each provider provides its own stub implementation as a <code>juzu.impl.template.spi.TemplateStub</code> subclass.</p>
</div>
<div class="paragraph">
<p>A stub must provide a public constructor accepting a <code>java.lang.String</code> argument: the template id. The template
 id if the class name of the generated template. In addition, a stub must implement two abstract methods:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java">  <span class="comment">/**
   * Init the template with the associated resource.
   *
   * @param loader   the class loader
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> doInit(<span class="predefined-type">ClassLoader</span> loader);

  <span class="comment">/**
   * Performs template rendering.
   *
   * @param renderContext the render context
   * @throws TemplateExecutionException any execution exception
   * @throws IOException any io exception
   */</span>
  <span class="directive">protected</span> <span class="directive">abstract</span> <span class="type">void</span> doRender(TemplateRenderContext renderContext)
      <span class="directive">throws</span> TemplateExecutionException, <span class="exception">IOException</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doInit</code> method loads the template using the provided <code>ClassLoader</code>, it will be call only once before the
template is rendered. Usually it uses the template id provided during the construction of the template to
locate the template on the disk, in its original form or in its compiled form.</p>
</div>
<div class="paragraph">
<p>The <code>doRender</code> method renders the template using the provided <code>TemplateRenderContext</code>. The render context
provides the necessary hooks such as:</p>
</div>
<div class="ulist">

<ul>
<li>
<p>Producing markup</p>
</li>
<li>
<p>Setting the title</p>
</li>
<li>
<p>Obtaining the locale</p>
</li>
<li>
<p>Accessing parameters or application beans for resolving expressions</p>
</li>
</ul>
</div>

</div>

</div>
</div>
<div class="sect1">
<h2 id="_template_at_work"><a class="anchor" href="#_template_at_work"></a>Template at work</h2>
<div class="sectionbody">
<div class="paragraph">
<p>After having described the various pieces of the templating SPI, let&#8217;s look at how the template generated stubs
 are used by Juzu templating system at runtime.</p>
</div>
<div class="paragraph">
<p>When the controller declares the <em>index.gtmpl</em> template the compiler produces three artifacts
* the <code>index</code> class template inherits <code>juzu.template.Template</code>: it is the only class visible from the
controller and the whole application
* the <em>index</em>.groovy_ Groovy template is the effective template code: it produces the markup, resolve expressions, etc&#8230;</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="images/request/interaction3.png" alt="At work" width="250">
</div>
<div class="title">Figure 3. index groovy at work</div>
</div>
<div class="paragraph">
<p>When a controller is instantiated, the <code>index</code> template instance is injected into the controller, the <code>@Path</code> annotation
plays an essential role because it&#8217;s a qualifier and that qualifier is used to distinguish the correct subclass to inject
in the controller.</p>
</div>
<div class="paragraph">
<p>When the template is created, the corresponding template stub is instantiated. When the template needs to be
rendered, the <code>doInit(ClassLoader)</code> method of the stub is invoked. At this moment the Groovy <code>index_</code> class is
loaded from the  class loader, when the class is not found, the <em>index</em>.groovy_ is loaded and it is compiled
on the fly.</p>
</div>

</div>
</div>
<div class="sect1">
<h2 id="_qualified_template_class"><a class="anchor" href="#_qualified_template_class"></a>Qualified template class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Controller can be injected with the <code>juzu.template.Template</code> class, however they can also be injected with
the template subclass that was genereted by Juzu: instead of using the qualified template injection,
the controller declares the template <em>index</em> subclass. This approach cab be used when type safe parameters
are used as only the <code>index</code> type declares the fluent API.</p>
</div>
<div class="paragraph">
<p>For instance if the <em>index.gtmpl</em> declares the <em>color</em> parameter the <code>index</code> class will look like:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="annotation">@Path</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">index.gtmpl</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">index</span> <span class="directive">extends</span> Template {

  ...

  public index with() {
    <span class="keyword">return</span> <span class="keyword">new</span> index.Builder();
  }

  <span class="directive">public</span> <span class="type">class</span> <span class="class">Builder</span> <span class="directive">extends</span> Template.Builder {

    <span class="directive">public</span> Builder color(<span class="predefined-type">String</span> color) {
      <span class="comment">// Generated code</span>
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The controller can then use the fluent API:</p>
</div>
<div class="listingblock">

<div class="content monospaced">
<pre class="CodeRay"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Controller</span> {

  <span class="annotation">@Inject</span>
  <span class="annotation">@Path</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">index.gtmpl</span><span class="delimiter">&quot;</span></span>)
  Template index;

  <span class="annotation">@View</span>
  <span class="directive">public</span> Response.Content index() {
    <span class="keyword">return</span> index.with().color(<span class="string"><span class="delimiter">&quot;</span><span class="content">red</span><span class="delimiter">&quot;</span></span>).ok();
  }
}</code></pre>
</div>
</div>

</div>
</div>


</div>
<div id="footer">
<div id="footer-text">
Last updated 2014-04-28 12:44:53 CEST
</div>
</div>
</body>
</html>